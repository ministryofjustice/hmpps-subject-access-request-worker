package uk.gov.justice.digital.hmpps.subjectaccessrequestworker.services

import com.google.gson.Gson
import com.itextpdf.kernel.pdf.PdfDocument
import com.itextpdf.kernel.pdf.PdfReader
import com.itextpdf.kernel.pdf.canvas.parser.PdfTextExtractor
import com.itextpdf.layout.Document
import org.apache.commons.io.FileUtils
import org.apache.commons.lang3.StringUtils
import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.io.TempDir
import uk.gov.justice.digital.hmpps.subjectaccessrequestworker.models.DpsService
import uk.gov.justice.digital.hmpps.subjectaccessrequestworker.models.ReportParameters
import uk.gov.justice.digital.hmpps.subjectaccessrequestworker.models.SubjectAccessRequest
import java.io.ByteArrayOutputStream
import java.nio.file.Files
import java.nio.file.Path
import java.nio.file.Paths
import java.time.LocalDate
import java.util.UUID

class PdfServiceTest {

  private lateinit var legacyPdfService: GeneratePdfService
  private lateinit var newPdfService: PdfService

  @TempDir
  private lateinit var tempDir: Path

  companion object {
    const val TEST_DATA_PATH = "service-data-stubs/book-secure-move-test-data.json"
  }

  @BeforeEach
  fun setup() {
    this.legacyPdfService = GeneratePdfService()
    this.newPdfService = PdfService()
  }

  @Test
  fun `PDFs generated by new service matches those generated by legacy service`() {
    val params = ReportParameters(
      services = listOf(DpsService(name = "hmpps-book-secure-move-api", orderPosition = 1, content = getTestData())),
      nomisId = "1234",
      ndeliusCaseReferenceId = "nDeliusRef123",
      sarCaseReferenceNumber = "sarCaseRef",
      subjectName = "Lord Voldemort",
      dateFrom = LocalDate.now().minusYears(1),
      dateTo = LocalDate.now(),
      subjectAccessRequest = SubjectAccessRequest(id = UUID.randomUUID()),
    )

    val legacySarPdf = generateLegacyReport(params).toFile()
    val newSarPdf = generateNewReport(params).toFile()

    assertThat(legacySarPdf.isFile).isTrue()
    assertThat(newSarPdf.isFile).isTrue()
    assertThat(Files.size(legacySarPdf.toPath())).isEqualTo(Files.size(newSarPdf.toPath()))

    // Compare the test of each page.
    Document(PdfDocument(PdfReader(legacySarPdf))).use { original ->
      Document(PdfDocument(PdfReader(newSarPdf))).use { refactored ->
        val legacyPdf = original.pdfDocument
        val newPdf = refactored.pdfDocument

        assertThat(legacyPdf.numberOfPages).isEqualTo(newPdf.numberOfPages)

        for (i in 1 until legacyPdf.numberOfPages) {
          val originalPage = PdfTextExtractor.getTextFromPage(legacyPdf.getPage(i))
          val refactorPage = PdfTextExtractor.getTextFromPage(newPdf.getPage(i))

          assertThat(refactorPage)
            .withFailMessage("Refactored PDF did not match legacy PDF content. Diff: (Page $i) \"${StringUtils.difference(originalPage, refactorPage)}\"")
            .isEqualTo(originalPage)
        }
      }
    }
  }

  private fun generateLegacyReport(params: ReportParameters): Path {
    return legacyPdfService.execute(
      services = params.services,
      nomisId = params.nomisId,
      ndeliusCaseReferenceId = params.ndeliusCaseReferenceId,
      sarCaseReferenceNumber = params.sarCaseReferenceNumber,
      subjectName = params.subjectName,
      dateFrom = params.dateFrom,
      dateTo = params.dateTo,
      subjectAccessRequest = params.subjectAccessRequest,
      pdfStream = ByteArrayOutputStream(),
    ).use { stream ->
      Files.write(tempDir.resolve("sar-legacy.pdf"), stream.toByteArray())
    }
  }

  private fun generateNewReport(params: ReportParameters): Path {
    return newPdfService.generateSubjectAccessRequestPDF(params).use { stream ->
      Files.write(tempDir.resolve("sar-new.pdf"), stream.toByteArray())
    }
  }

  fun getTestData(): Any {
    val testData = PdfServiceTest::class.java.classLoader.getResource(TEST_DATA_PATH)?.readText()
//    val jsonStr = Files.readString(Paths.get(TEST_DATA_PATH))
    val map: Map<*, *> = Gson().fromJson(testData, Map::class.java)
    return map["content"] as Any
  }
}